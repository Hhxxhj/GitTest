# 各种名词解释

------



1. `bin`：后缀为bin的文件一般就是可执行文件

1. `make install`： 命令通常用于编译和安装软件包，特别是在 Unix/Linux 系统上。它的主要作用是将经过编译的程序和文件复制到系统的适当位置，以便用户可以方便地执行和使用这些程序

1. `交叉编译`： 是一种在一种平台上生成可在另一种平台上运行的二进制可执行文件的过程。这种方法非常常见，尤其是在嵌入式系统开发中。在开发嵌入式系统时，常常在PC等开发环境中编写程序，然后将程序移植到 ARM 或其他架构的硬件设备上运行

1. `临界区`：是操作系统中并发编程的核心概念，指一段**必须互斥访问**的代码或资源

1. `自旋锁`：用于进程之间互斥访问临界区资源，当一个线程持有该锁时，如果其他线程需要访问对应地临界区资源，则只会原地等着，而不会去做其他事情，类似于在**原地转圈圈等待**，所以该锁被称为自旋锁

1. `系统时钟源`：提供系统的基本时间信息，用于文件时间戳、日志记录等。操作系统依据系统时钟源来安排和管理进程的CPU时间，提高系统的并发处理能力

1. `系统中断`：中断可以由硬件或软件触发，目的是将CPU的注意力从当前任务转移到服务另一个任务或事件上。这种机制使得操作系统能够高效地管理资源和响应事件

1. `上下文`：上下文可以是指代码执行的环境或状态。在 Linux 内核中，代码通常在两个主要的上下文中运行：**进程上下文**和**中断上下文**。
   1. **进程上下文**是指代码在用户空间进程执行时的状态。系统可以执行更**复杂**的任务，比如读取文件或与设备通信
   1. **中断上下文**是指代码在处理硬件中断时的状态（当硬件设备（比如键盘、鼠标或网络卡）发送信号给计算机时，CPU会中断正在做的事情，去处理这个信号。这个处理过程称为在**中断上下文**中运行）在中断上下文中，执行的代码**必须非常快速**，并且不能阻塞或进行太长时间的操作，因为这会影响系统的响应能力

1. `软中断与硬中断`：中断是指计算机在执行程序时，由于外部或内部事件的发生，暂停当前程序的执行，转而执行中断处理程序的机制。根据中断的来源和处理方式，通常可以分为**硬中断（Hard IRQ）和软中断（Soft IRQ）**。linux中大部分中断都是硬件中断，包括进程调度时的中断（由时钟触发）

   1. **硬中断（Hard IRQ）**：

      **硬中断**(硬件中断)是由外部硬件设备发起的中断，通常用于响应外部事件，如定时器中断、外设（如键盘、鼠标、网络接口卡等）请求的中断。硬中断的特点包括：

      - **硬件触发**：硬中断通常是由硬件设备触发的，如外部设备发送信号给处理器，表示它需要处理。
      - **高优先级**：硬中断的优先级非常高，它会中断正在执行的程序，确保及时响应外部事件。硬中断处理程序（中断服务例程，ISR）通常会立即执行。
      - **快速响应**：硬中断必须尽快得到处理，以防丢失重要的外部事件信息。硬中断的处理通常是非常快速的，不允许进行睡眠、等待等操作。

   1. **软中断（Soft IRQ）**：

      **软中断**(软件中断)是内核在软中断上下文中处理的中断，通常是由内核调度的，它并不直接由硬件触发，而是由操作系统内部事件驱动。软中断主要用于延迟处理一些非紧急、但需要及时执行的任务。软中断的特点包括：

      - **内核调度触发**：软中断由内核内部的事件触发，如定时器、网络包处理等。
      - **较低优先级**：软中断的优先级低于硬中断，它通常在硬中断处理完成后或系统空闲时执行。
      - **延迟执行**：软中断通常用于处理那些不紧急的任务，比如网络数据包的处理、设备 I/O 完成的处理等，它们的执行可能会延迟。
      - **不可抢占**：在软中断执行过程中，它不能被打断，也不能被其他软中断抢占。
   
1. 





# 系统移植

------



## 1 U-Boot使用实验

**理解**：uboot是个**裸机程序**，因此需要在其前面加上**头部(IVT、DCD等数据)**才能在I.MX6U 上执行

- **裸机程序**：U-Boot本身并不依赖操作系统，它直接运行在硬件上，进行系统引导、加载内核等操作

- **头部(IVT、DCD等数据)**：

  - **IVT (Initial Vector Table)**：初始向量表，它包含了U-Boot启动时需要的信息，比如启动地址、U-Boot的入口点等，告诉处理器从哪里开始执行。
  - **DCD (Device Configuration Data)**：设备配置数据，它是硬件的配置信息，告诉U-Boot如何初始化硬件资源。

  - 这些数据是U-Boot启动过程中需要的“元数据”，它们通常位于U-Boot映像的前面，帮助处理器在启动时正确地初始化硬件和程序。



**交叉编译**（Cross-compiling）是指在一种平台上（通常是开发环境或主机平台）编译代码，生成能够在另一种平台上（目标平台或嵌入式设备）运行的可执行文件的过程。简单来说，就是在一个平台（比如你的PC）上编译代码，生成在另一个不同架构（比如嵌入式设备、ARM处理器等）上能够执行的程序。



## 2 ubutun、电脑、板子三方互相ping通

[详细教程](https://blog.csdn.net/weixin_55255438/article/details/123461061)

通过上述教程配置之后，ip地址如下，但是发现开发板uboot和ubutun之间可以ping通，但是uboot和主机之间无法ping通

**主机ip地址**：192.168.137.12

**虚拟机ip地址**：192.168.137.10

**板子ip地址**：192.168.137.11

## 3 uboot内使用nfs指令的问题

**问题描述**：下载内容时出现 `Loading: *** ERROR: File lookup fail`，或者出现 `打印 T T T...` 解决方法如下

https://zhuanlan.zhihu.com/p/679302530

## 4 ubutun虚拟机切换NAT和桥接模式

NAT模式是为了上网，桥接模式是为了连接开发板

**具体步骤如下**

1. 桥接模式时选择QIAOJIE，NAT模式选择NAT

   ![image-20250226121004027](C:\Users\12499\AppData\Roaming\Typora\typora-user-images\image-20250226121004027.png)

2. 虚拟机设置内修改桥接或是NAT

   ![image-20250226121328826](C:\Users\12499\AppData\Roaming\Typora\typora-user-images\image-20250226121328826.png)





## 5 U-boot启动流程

[教程链接](https://blog.csdn.net/xhj12138/article/details/133546295)，这个链接中只需要看最底下的总结部分即可

这个博主有其他的一些正点原子相关的文章，很值得看 https://blog.csdn.net/xhj12138/category_12438398.html

## 6 U-boot LCD屏幕驱动修改

1. 在mx6ull_alientek_emmc.c里面把该结构体进行如下修改

   ![image-20250306214600534](C:\Users\12499\AppData\Roaming\Typora\typora-user-images\image-20250306214600534.png)

2. 在mx6ull_alientek_emmc.h里面把 panel = xxx 改为 panel = ATK-LCD-4.3-800X480

3. 烧录完之后，在uboot界面里面

```
setenv panel ATK-LCD-4.3-800X480
saveenv
```

## 7 uboot移植概念总结

1. 不管是购买的开发板还是自己做的开发板，基本都是参考半导体厂商的 dmeo 板，而 半导体厂商会在他们自己的开发板上移植好uboot、linux kernel 和 rootfs 等，最终制作好 BSP 包提供给用户。我们可以在官方提供的BSP包的基础上添加我们的板子，也就是俗称的移植
2. 我们购买的开发板或者自己做的板子一般都不会原封不动的照抄半导体厂商的 demo 板，都会根据实际的情况来做修改，既然有修改就必然涉及到uboot下驱动的移植
3. 一般uboot中需要解决串口、NAND、EMMC或SD卡、网络和LCD驱动，因为uboot 的主要目的就是启动Linux内核，所以不需要考虑太多的外设驱动
4. 在uboot中添加自己的板子信息，根据自己板子的实际情况来修改uboot中的驱动

> - **BSP 包是一个软件集合**：它包含了操作系统 (例如 Linux) 在特定硬件平台（也就是你的开发板）上运行所需的所有软件组件，可以看作是操作系统和硬件之间的桥梁
>
> - **BSP 包的内容**：通常包括：
>   - **启动加载器 (Bootloader)**：例如 U-Boot，负责初始化硬件、加载操作系统内核。
>   - **操作系统内核 (Kernel)**：例如 Linux 内核，是操作系统的核心。
>   - **设备驱动程序 (Device Drivers)**：用于控制硬件设备，例如串口、网卡、显示器、存储设备等。
>   - **文件系统 (File System)**：例如 rootfs，包含操作系统运行所需的基本文件和应用程序。
>   - **配置文件 (Configuration Files)**：用于配置操作系统和驱动程序。
>   - **工具 (Tools)**：用于编译、调试和烧写软件。
>   - **文档 (Documentation)**：提供 BSP 包的使用说明和开发指导。

## 8 Linux顶层makefile

arch/arm/configs目录是不同平台的默认配置文件：xxx_defconfig。xxx_defconfig的里面存储着针对不同硬件平台的一些配置选项



make xxx_defconfig这行命令会发生如下事件：

1. **查找 `xxx_defconfig` 文件：** `make` 命令会在内核源码树中的特定位置查找 `acs5k_defconfig` 文件。通常，这些文件位于 `arch/<architecture>/configs/` 目录下，其中 `<architecture>` 是你的目标体系结构（例如，`arm`、`x86` 等）。
2. **读取配置选项：** `make` 命令会读取 `acs5k_defconfig` 文件中的所有配置选项及其对应的值。
3. **生成 `.config` 文件：** `make` 命令会根据读取到的配置选项生成一个名为 `.config` 的文件。`.config` 文件包含了内核的所有配置选项，以及它们的值。
4. **更新 Makefile：** 在生成 `.config` 文件之后，`make` 命令还会更新内核源码树中的 Makefile 文件，以便在编译内核时使用这些配置选项



`xxx_defconfig`、`.config` 和 Linux 内核源码配置之间的关系：

1. **`xxx_defconfig` 文件：**
   - 是 Linux 内核源码树中提供的**预定义配置模板**，其中 `xxx` 通常代表一个特定的平台、设备或使用场景。
   - 包含了针对该平台、设备或场景的**默认配置选项**及其对应的值，例如 `CONFIG_NET_ETHERNET=y`。
   - 位于 `arch/<architecture>/configs/` 目录下，其中 `<architecture>` 是目标体系结构。
   - 作用是**提供一个可用的基础配置**，简化配置过程，并作为其他配置目标的基准。
2. **`.config` 文件：**
   - 是 Linux 内核的**最终配置文件**，包含了编译内核所需的所有配置选项及其值。
   - 位于内核源码树的**顶层目录**。
   - 可以通过多种方式生成，包括：
     - `make xxx_defconfig`：使用 `xxx_defconfig` 文件生成 `.config` 文件。
     - `make menuconfig`、`make xconfig`、`make gconfig`：通过图形化界面手动配置内核选项，并生成 `.config` 文件。
     - 手动编辑：直接使用文本编辑器修改 `.config` 文件（不推荐）。
   - 作用是**指导内核编译系统**，告诉它应该编译哪些特性和驱动，以及如何配置它们。
3. **Linux 内核源码配置：**
   - 指的是**配置内核的过程**，即选择哪些内核特性和驱动要编译，以及如何设置内核的各种参数。
   - 这个过程的**最终结果是生成 `.config` 文件**，它包含了内核的所有配置选项。
   - 可以通过多种方式进行，包括：
     - 使用 `xxx_defconfig` 文件作为基础配置，然后手动修改。
     - 从零开始手动配置内核选项。
     - 使用已有的 `.config` 文件。

**总结：**

- `xxx_defconfig` 类似于一个“种子”，它提供了一个针对特定平台或设备的默认配置。
- `.config` 是最终的“成果”，它包含了内核的所有配置选项，并指导编译系统。
- Linux 内核源码配置是一个过程，它将 `xxx_defconfig` 文件作为起点，最终生成 `.config` 文件。

简单来说，你可以把 `xxx_defconfig` 看作是一个预设方案，`.config` 是最终方案，而 Linux 内核源码配置就是制定最终方案的过程。

## 9 Linux启动过程

### init进程如何初始化

第394行，调用函数**kernel_thread创建kernel_init进程**，也就是大名鼎鼎的init内核进程。 init进程的PID为1。kernel_init进程一开始是内核进程(也就是运行在内核态)，后面kernel_init进程会在根 文件系统中查找名为“init”这个程序，这个“init”程序处于用户态，通过运行这个“init”程 序，init进程就会实现从内核态到用户态的转变（`kernel_init` 进程会使用 `execve` 系统调用来执行用户态的 "init" 程序。使用`execve` 系统调用来完成内核态到用户态的转变。`execve` 系统调用不仅加载了新的用户态程序，而且还设置了用户态的上下文，并最终将进程的运行状态切换到用户态）。  

第396行，调用函数**kernel_thread创建kthreadd**内核进程，此内核进程的**PID为2**。kthreadd 进程负责所有内核进程的调度和管理。  

第409行，最后调用函数**cpu_startup_entry来进入idle进程（idle进程是内核进程，“ps -A”命令查找不出来）**，cpu_startup_entry会调用 cpu_idle_loop，cpu_idle_loop是个while循环，也就是idle进程代码。idle进程的PID为0，idle 进程叫做空闲进程，如果学过FreeRTOS或者UCOS的话应该听说过空闲任务。idle空闲进程 就和空闲任务一样，当CPU没有事情做的时候就在idle空闲进程里面“瞎逛游”，反正就是给 CPU找点事做。当其他进程要工作的时候就会抢占idle进程，从而夺取CPU使用权。其实大 家应该可以看到idle进程并没有使用kernel_thread或者fork函数来创建，因为它是有主进程演 变而来的。



### uboot、Linux kernel 和 rootfs 之间的关系

uboot、Linux kernel 和 rootfs 这三者在 Linux 移植中的关系，以及它们如何共同构成一个完整的 Linux 操作系统：

**1. 三者之间的关系：**

- **U-Boot（通用引导加载器）：** 相当于电脑的 BIOS。它在系统启动时首先运行，负责初始化硬件（如 CPU、内存等），然后将 Linux 内核加载到内存中，并将控制权交给内核。简单来说，U-Boot 的作用是“引导” Linux 内核启动。
- **Linux Kernel（Linux 内核）：** 是操作系统的核心。它负责管理系统的硬件资源（CPU、内存、I/O 设备等），提供系统调用接口给用户程序使用。内核是操作系统的“大脑”。
- **Rootfs（根文件系统）：** 包含了启动 Linux 系统所需的必要文件和目录，例如 /bin, /etc, /lib, /usr 等。它提供了用户程序运行的环境。可以把它看作是操作系统的“骨架”和“血肉”。

**2. 启动过程和最终变成 Linux 系统的过程：**

1. **启动 U-Boot：** 系统上电后，首先运行 U-Boot。
2. **U-Boot 初始化硬件：** U-Boot 初始化 CPU、内存、时钟等基本硬件。
3. **加载 Kernel 到内存：** U-Boot 从存储介质（如 Flash、SD 卡等）中读取 Linux 内核镜像，并将其加载到内存中的指定位置。
4. **传递参数给 Kernel：** U-Boot 可以通过 bootargs 环境变量将启动参数传递给 Linux 内核。这些参数可以指定 rootfs 的位置、console 设备等。
5. **启动 Kernel：** U-Boot 跳转到 Linux 内核的入口地址，将控制权交给内核。
6. **Kernel 初始化：** Linux 内核接管系统后，开始初始化自身，包括初始化中断、内存管理、设备驱动等。
7. **挂载 Rootfs：** 内核根据 U-Boot 传递的参数，找到 rootfs 所在的位置，并将其挂载为根目录 "/"。
8. **启动 init 进程：** 内核启动 rootfs 中的 init 进程（通常是 /sbin/init），init 进程是用户空间的第一个进程，负责启动其他的系统服务和应用程序。
9. **系统启动完成：** init 进程启动完成后，Linux 系统就启动完成了，用户可以登录系统并开始使用。

**总结：**

U-Boot 负责引导 Linux 内核，Linux 内核负责管理硬件资源，rootfs 提供了用户程序运行的环境。三者协同工作，最终构成一个完整的、可以运行的 Linux 操作系统。

### 10 Linux内核移植

1. 在Linux内核中查找可以参考的板子，一般都是半导体厂商自己做的开发板。 
2. 编译出参考板子对应的zImage和.dtb文件。  
3. 使用参考板子的zImage文件和.dtb文件在我们所使用的板子上启动Linux内核，看能 否启动。 
4. 如果能启动的话就万事大吉，如果不能启动那就悲剧了，需要调试Linux内核。不过 一般都会参考半导体官方的开发板设计自己的硬件，所以大部分情况下都会启动起来。启动 Linux 内核用到的外设不多，一般就DRAM(Uboot都初始化好的)和串口。作为终端使用的串口 一般都会参考半导体厂商的Demo板。  
5. 修改相应的驱动，像NAND Flash、EMMC、SD卡等驱动官方的Linux内核都是已经 提供好了，基本不会出问题。重点是网络驱动，因为Linux驱动开发一般都要通过网络调试代 码，所以一定要确保网络驱动工作正常。如果是处理器内部 MAC+外部 PHY这种网络方案的 话，一般网络驱动都很好处理，因为在Linux内核中是有外部PHY通用驱动的。只要设置好复 位引脚、PHY地址信息基本上都可以驱动起来。  
6. Linux 内核启动以后需要根文件系统，如果没有根文件系统的话肯定会崩溃，所以确定Linux 内核移植成功以后就要开始根文件系统的构建。 





# 驱动开发

------

`linux驱动`：封装对底层硬件的操作，向上层应用提供操作接口。**驱动与底层硬件直接打交道，充当了硬件与应用软件中间的桥梁**

## 1 常用命令

1. `depmod`：用于生成模块依赖关系和符号表文件。确保 Linux 内核模块正常工作的重要工具，它帮助系统在管理和加载模块时理解各个模块之间的关系和符号
2. `modprobe`：用于加载和卸载内核模块的命令，通常与 `depmod` 一起使用。使用 `modprobe` 可以加载一个指定的内核模块，同时自动解析并加载其所依赖的其他模块。用 `modprobe -r` 命令卸载指定的模块，这也会自动卸载其依赖的模块（如果没有其他模块依赖于它）
3. `lsmod`：查看当前系统中存在的模块
4. `rmod`：卸载模块

## 2 驱动相关名词概念

1. `设备节点与设备对象`：设备节点和设备对象之间的关系可以理解为**描述和实例化**的关系。

   1. **设备节点（Device Node）**：它是设备树中的一个条目，描述了硬件设备的基本信息，如设备的名称、类型、内存地址、IRQ（中断）资源等。设备节点并不是一个实际的硬件实例，而是一个抽象的描述，它告诉操作系统硬件设备的存在及其配置。

   2. **设备对象（Device Object）**：这是在驱动程序中创建的实际实例。驱动程序根据设备树中的设备节点定义，注册设备对象，并将其与硬件资源关联。设备对象通常会在内核中作为结构体实例存在，代表一个具体的硬件设备，并由驱动程序控制和管理。

   3. **关系**：**设备树节点**提供了设备的**元数据**（例如，设备的类型、内存映射、IO资源等），它本身并不控制硬件。**设备对象**是在驱动程序中创建的，它将设备树中的描述信息转化为操作系统中实际可操作的设备实例。设备对象是在内核中具体实现的，驱动程序利用这些设备对象进行硬件交互和操作。

      

## 3 Linux下应用程序调用驱动流程

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/1114b0b5a6481fff5da2ad762f1aa811.png)

- Linux下进行驱动开发，完全将驱动程序与应用程序隔开，中间通过**C标准库函数**以及**系统调用**完成驱动层和应用层的数据交换。

- 驱动加载成功以后会在“/dev”目录下生成一个相应的文件，应用程序通过**对“/dev/xxx” (xxx 是具体的驱动文件名字) 的文件进行相应的操作**即可实现对硬件的操作。
- 用户空间不能直接对内核进行操作，因此必须使用一个叫做 **“系统调用”的方法** 来实现从用户空间“陷入” 到内核空间，这样才能实现对底层驱动的操作
- 每一个**系统调用**，在驱动中都有与之**对应的一个驱动函数**，在 Linux 内核文件 include/linux/fs.h 中有个叫做 **file_operations 的结构体**，此**结构体就是 Linux 内核驱动操作函数集合。**

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/95ac162bffbd7df4a3411475a0b58934.png)

- 加载一个驱动模块，产生一个**设备文件（/dev/xxx）**，有唯一对应的**inode结构体**
- 应用层调用**open函数**打开设备文件，对于上层open调用到内核时会发生一次**软中断**，从用户空间进入到**内核空间**。
- open会调用到**sys_open(内核函数)**，sys_open根据**文件的地址**，找到设备文件对应的**struct inode结构体**描述的信息，可以知道接下来要操作的设备类型（字符设备还是块设备），还会**分配一个struct file结构体**。
- 根据struct inode结构体里面记录的**主设备号和次设备号**，在**驱动链表**(管理所有设备的驱动)里面，根据**找到字符设备驱动**
- 每个字符设备都有一个**struct cdev结构体**。此结构体描述了字符设备所有信息，其中最重要的一项就是**字符设备的操作函数接口**
- 找到**struct cdev结构体**后，linux内核就会将struct cdev结构体所在的**内存空间首地址**记录在**struct inode结构体i_cdev成员中**，将struct cdev结构体中的记录的**函数操作接口地址记录在struct file结构体的f_ops成员**中。
- 执行xxx_open驱动函数。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2dcbfda1e8dd7df5898c9990b883a7c4.png)

## 4 LED驱动开发实验

**Linux 下的任何外设驱动，最终都是要配置相应的硬件寄存器**。所以本章的 LED 灯驱动最终也是对 I.MX6ULL 的 IO 口进行配置，与裸机实验不同的是，在 Linux 下编写驱动要符合 Linux 的驱动框架

**主设备号**：决定设备归哪个驱动程序管理，在编写驱动程序时使用

**次设备号**：由驱动决定，通常用于区分同类设备，在创建设备时使用 `mknod /dev/led2 c 200 1   #次设备号 1` ，这里的led2名字不需要和led.c内的设备名字相同，只需要`设备号相同即可`

### val &= ~(1 << 3) 解析



- **1 << 3**：表示把1左移3位，假设一共有32位。即：0000 0000 0000 0000 0000 0000 0000 0001 -> 0000 0000 0000 0000 0000 0000 0000 1000
-  **~(1 << 3)**：取反。即：0000 0000 0000 0000 0000 0000 0000 1000 -> 1111 1111 1111 1111 1111 1111 1111 0111
- **val &= ~(1 << 3)**：表示把val与前面所得到的结果进行**与操作**，**最终达到的结果即为将第三位的值设置为0**

###  寄存器

`设备的地址范围，其实就是能够操作这个设备的寄存器(这些寄存器是设备自身的寄存器)的地址范围`

`操作设备 = 配置该设备对应的寄存器`

**CPU寄存器 CPU寄存器（通用寄存器）**：

- 通用寄存器（ARM中有37个）是CPU的组成部分，CPU的很多活动都需要通用寄存器的支持和参与。
- 专用指令执行、数据运算、变量处理、参数传递

**外设寄存器 外设寄存器（SFR）**：

- SFR（special function register，特殊功能寄存器）不在CPU中，而存在于CPU的外设中，我们通过访问外设的SFR来编程操控这个外设，这就是硬件编程控制的方法。
- 用于控制外设的行为和工作方式。
- 寄存器值的配置需要根据芯片手册完成。

对于外设寄存器来说：
寄存器属于CPU外设的硬件组成部分。 CPU可以像访问内存一样访问寄存器。 寄存器是CPU的硬件设计者制定的，目的是留作外设被编程控制的“活动开关”。 正如汇编指令集是CPU的编程接口API一样，寄存器是外设硬件的软件编程接口API。使用软件编程控制某一硬件，其实就是编程读写该硬件的寄存器。 编程操作寄存器类似于访问内存。 寄存器中每个bit位都有特定含义，因此编程操作时需要位操作。 单个寄存器的位宽一般和CPU的位宽一样，以实现最佳访问效率。

## 5 platform设备驱动实验

![image-20250327214601161](C:\Users\12499\AppData\Roaming\Typora\typora-user-images\image-20250327214601161.png)

**总线、驱动和设备模型**：其中总线指I2C，SPI，USB等总线，或者platform(虚拟总线)

[Linux 总线、设备、驱动模型的探究](https://github.com/0voice/linux_kernel_wiki/blob/main/%E6%96%87%E7%AB%A0/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/Linux%20%E6%80%BB%E7%BA%BF%E3%80%81%E8%AE%BE%E5%A4%87%E3%80%81%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%8E%A2%E7%A9%B6.md)

[参考链接](https://www.cnblogs.com/lizhuming/p/14596239.html#tid-J3H65J)

- `总线`：负责管理挂载对应总线的设备以及驱动，总线代表同类设备需要共同遵守的时序，不同总线硬件的通信时序也是不同的，如I2c总线、USB总线、PCI总线
- `设备`：挂载在某个总线的物理设备，设备代表真实存在的物理器件，每个器件有自己不同的通信时序，I2C、USB这些都代表不同的时序，这就与总线挂钩了
- `驱动`：与特定设备相关的软件，负责初始化该设备以及提供一些操作该设备的操作方式，驱动代表操作设备的方式和流程，以应用来说，在程序open设备时，接着read这个这个设备，驱动就是实现应用访问的具体过程。驱动就是一个通信官和翻译官，一是通过对soc的控制寄存器编程，按总线要求输出相应时序的命令，与设备交互，一是对得到数据进行处理，给上层提供特定格式数据



> platform_driver 用于描述platform驱动，platform_device 用于描述platform设备
>
> 如果内核支持设备树的话就不要再使用 platform_device 来描述设备了，因为改用设备树去描述了，Linux内核启动时会从设备树中读取设备信息，然后将其组织成 platform_device 形式



**platform**：类似于一个框架，用于更好的更方便清晰的进行驱动开发

device_driver类似与platform_driver的一个基类，platform_driver在其上面进行了一些特有的成员变量，因此写代码时，需要向device_driver类的driver里面填写一些内容。**使用platform写驱动时，本质上就是根据需要填写platform_driver里面的各种成员变量，并注册他**
